{
    "data": [
        {
            "function": "    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }",
            "tests": [
                "    function testDirectSetApprovalForAll(address by, address operator, bool approved) public {\n        token = new MockERC1155();\n        _expectApprovalForAllEvent(by, operator, approved);\n        vm.prank(by);\n        token.directSetApprovalForAll(operator, approved);\n    }"
            ],
            "description": "This function allows a user (the \"sender\") to specify whether another user's approval for certain operators should be considered. When this function is called, it updates the approval status and notifies all other users of the change."
        },
        {
            "function": "    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }",
            "tests": [
                "    function testSafeTransferFromToEOA(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        _expectMintEvent(t.from, t.id, t.mintAmount);\n        token.mint(t.from, t.id, t.mintAmount, t.mintData);\n\n        if (_randomChance(2)) {\n            _expectTransferEvent(t.from, t.to, t.id, t.transferAmount);\n            token.uncheckedSafeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n        } else if (_randomChance(8)) {\n            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);\n            _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n            return;\n        } else {\n            vm.prank(t.from);\n            _setApprovalForAll(address(this), true);\n\n            _expectTransferEvent(t.from, t.to, t.id, t.transferAmount);\n            _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n        }\n\n        if (t.to == t.from) {\n            assertEq(token.balanceOf(t.to, t.id), t.mintAmount);\n        } else {\n            assertEq(token.balanceOf(t.to, t.id), t.transferAmount);\n            assertEq(token.balanceOf(t.from, t.id), t.mintAmount - t.transferAmount);\n        }\n    }",
                "    function testSafeTransferFromToERC1155Recipient(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        _expectMintEvent(t.from, t.id, t.mintAmount);\n        token.mint(t.from, t.id, t.mintAmount, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        _expectTransferEvent(t.from, address(to), t.id, t.transferAmount);\n        _safeTransferFrom(t.from, address(to), t.id, t.transferAmount, t.transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), t.from);\n        assertEq(to.id(), t.id);\n        assertEq(to.mintData(), t.transferData);\n\n        assertEq(token.balanceOf(address(to), t.id), t.transferAmount);\n        assertEq(token.balanceOf(t.from, t.id), t.mintAmount - t.transferAmount);\n    }",
                "    function testSafeTransferFromSelf(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        _expectMintEvent(address(this), t.id, t.mintAmount);\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n\n        _expectTransferEvent(address(this), t.to, t.id, t.transferAmount);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n\n        assertEq(token.balanceOf(t.to, t.id), t.transferAmount);\n        assertEq(token.balanceOf(address(this), t.id), t.mintAmount - t.transferAmount);\n    }",
                "    function testSafeTransferFromInsufficientBalanceReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();\n\n        t.transferAmount = _bound(t.transferAmount, t.mintAmount + 1, type(uint256).max);\n\n        token.mint(t.from, t.id, t.mintAmount, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        vm.expectRevert(ERC1155.InsufficientBalance.selector);\n        _safeTransferFrom(t.from, t.to, t.id, t.transferAmount, t.transferData);\n    }",
                "    function testSafeTransferFromSelfInsufficientBalanceReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n        while (t.mintAmount == type(uint256).max) t.mintAmount = _random();\n\n        t.transferAmount = _bound(t.transferAmount, t.mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n\n        vm.expectRevert(ERC1155.InsufficientBalance.selector);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }",
                "    function testSafeTransferFromToZeroReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n\n        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);\n        _safeTransferFrom(address(this), address(0), t.id, t.transferAmount, t.transferData);\n    }",
                "    function testSafeTransferFromToNonERC155RecipientReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n        t.to = address(new NonERC1155Recipient());\n\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }",
                "    function testSafeTransferFromToRevertingERC1155RecipientReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n        t.to = address(new RevertingERC1155Recipient());\n\n        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector));\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }",
                "    function testSafeTransferFromToWrongReturnDataERC1155RecipientReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n        t.transferAmount = _bound(t.transferAmount, 0, t.mintAmount);\n\n        token.mint(address(this), t.id, t.mintAmount, t.mintData);\n        t.to = address(new WrongReturnDataERC1155Recipient());\n\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), t.to, t.id, t.transferAmount, t.transferData);\n    }"
            ],
            "description": "This function allows a user to safely transfer tokens from one account to another. The function checks if the sender is authorized or approved for the transfer, and then updates the token balances accordingly. After the transfer, it emits a notification event indicating the details of the transfer. Additionally, it verifies that the recipient is set up to handle the transferred tokens correctly by checking their `onERC1155Received` function against a standard implementation."
        },
        {
            "function": "    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }",
            "tests": [
                "    function testSafeBatchTransferFromToEOA(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n            userTransferOrBurnAmounts[t.from][id] += transferAmount;\n        }\n        _expectMintEvent(t.from, t.ids, t.mintAmounts);\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        if (_randomChance(2)) {\n            _expectTransferEvent(t.from, t.to, t.ids, t.transferAmounts);\n            token.uncheckedSafeBatchTransferFrom(\n                t.from, t.to, t.ids, t.transferAmounts, t.transferData\n            );\n        } else if (_randomChance(8)) {\n            vm.expectRevert(ERC1155.NotOwnerNorApproved.selector);\n            _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n            return;\n        } else {\n            vm.prank(t.from);\n            _setApprovalForAll(address(this), true);\n\n            _expectTransferEvent(t.from, t.to, t.ids, t.transferAmounts);\n            _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n        }\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            assertEq(token.balanceOf(t.to, id), userTransferOrBurnAmounts[t.from][id]);\n            assertEq(\n                token.balanceOf(t.from, id),\n                userMintAmounts[t.from][id] - userTransferOrBurnAmounts[t.from][id]\n            );\n        }\n    }",
                "    function testSafeBatchTransferFromToERC1155Recipient(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n            userTransferOrBurnAmounts[t.from][id] += transferAmount;\n        }\n\n        _expectMintEvent(t.from, t.ids, t.mintAmounts);\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        _expectTransferEvent(t.from, address(to), t.ids, t.transferAmounts);\n        _safeBatchTransferFrom(t.from, address(to), t.ids, t.transferAmounts, t.transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), t.from);\n        assertEq(to.batchIds(), t.ids);\n        assertEq(to.batchAmounts(), t.transferAmounts);\n        assertEq(to.batchData(), t.transferData);\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[t.from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(t.from, id), userMintAmounts[t.from][id] - transferAmount);\n        }\n    }",
                "    function testSafeBatchTransferFromToZeroReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        vm.expectRevert(ERC1155.TransferToZeroAddress.selector);\n        _safeBatchTransferFrom(t.from, address(0), t.ids, t.transferAmounts, t.transferData);\n    }",
                "    function testSafeBatchTransferFromToNonERC1155RecipientReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        t.to = address(new NonERC1155Recipient());\n\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n    }",
                "    function testSafeBatchTransferFromToRevertingERC1155RecipientReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        t.to = address(new RevertingERC1155Recipient());\n        vm.expectRevert(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector));\n        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n    }",
                "    function testSafeBatchTransferFromToWrongReturnDataERC1155RecipientReverts(uint256) public {\n        token = new MockERC1155();\n        _TestTemps memory t = _testTemps();\n\n        for (uint256 i = 0; i != t.n; i++) {\n            uint256 id = t.ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[t.from][id];\n\n            uint256 mintAmount = _bound(t.mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = _bound(t.transferAmounts[i], 0, mintAmount);\n\n            t.mintAmounts[i] = mintAmount;\n            t.transferAmounts[i] = transferAmount;\n\n            userMintAmounts[t.from][id] += mintAmount;\n        }\n\n        token.batchMint(t.from, t.ids, t.mintAmounts, t.mintData);\n\n        vm.prank(t.from);\n        _setApprovalForAll(address(this), true);\n\n        t.to = address(new WrongReturnDataERC1155Recipient());\n        vm.expectRevert(ERC1155.TransferToNonERC1155ReceiverImplementer.selector);\n        _safeBatchTransferFrom(t.from, t.to, t.ids, t.transferAmounts, t.transferData);\n    }",
                "    function testSafeBatchTransferFromWithArrayLengthMismatchReverts(uint256) public {\n        token = new MockERC1155();\n        uint256[] memory ids = new uint256[](_random() % 4);\n        uint256[] memory mintAmounts = new uint256[](_random() % 4);\n\n        if (ids.length == mintAmounts.length) return;\n\n        address from = address(0xABCD);\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        token.batchMint(from, ids, mintAmounts, _randomBytes());\n\n        uint256[] memory transferAmounts = new uint256[](_random() % 4);\n        if (ids.length == transferAmounts.length) return;\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        address to = _randomNonZeroAddress();\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        _safeBatchTransferFrom(from, to, ids, transferAmounts, _randomBytes());\n    }"
            ],
            "description": "This function allows for a safe batch transfer of tokens from one address to another. It ensures that the sender has authorization and that the recipient is connected to an approved contract, which handles token transfers safely. The function also updates the token balances and emits a notification when the transfer occurs. Additionally, it checks if the recipient can handle the received tokens correctly before allowing the transfer to complete."
        },
        {
            "function": "    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }",
            "tests": [
                "    function testBalanceOfBatchWithArrayMismatchReverts(uint256) public {\n        token = new MockERC1155();\n        address[] memory tos = new address[](_random() % 4);\n        uint256[] memory ids = new uint256[](_random() % 4);\n        if (tos.length == ids.length) return;\n\n        vm.expectRevert(ERC1155.ArrayLengthsMismatch.selector);\n        token.balanceOfBatch(tos, ids);\n    }"
            ],
            "description": "This function retrieves and returns the balance information of a batch of assets. It takes a list of asset owners and corresponding IDs as input, checks if they have an equal number, and then iterates over them to fetch their respective balances from another contract (balanceOf) and stores them in memory. The function does not modify any state or interact with external systems; it simply returns the calculated balance information."
        },
        {
            "function": "    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }",
            "tests": [
                "    function testApprove() public {\n    assertTrue(token.approve(address(0xBEEF), 1e18));\n\n    assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n}",
                "    function testApproveToPermit2(address owner, uint256 amount) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        vm.prank(owner);\n        if (amount != type(uint256).max) {\n            vm.expectRevert(ERC20.Permit2AllowanceIsFixedAtInfinity.selector);\n        }\n        token.approve(_PERMIT2, amount);\n    }",
                "    function testApprove() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        vm.expectEmit(true, true, true, true);\n        emit Approval(address(this), address(0xBEEF), 1e18);\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }",
                "    function testInfiniteApproveTransferFrom() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }",
                "    function testApprove(address to, uint256 amount) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }"
            ],
            "description": "This function allows a user to grant permission for another user's token to be spent. It specifies the amount of tokens that can be spent by the designated user and notifies other users of the approval through an emitted event."
        },
        {
            "function": "    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }",
            "tests": [
                "    function testTransferFrom(address owner, uint256 amount) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        assertEq(token.allowance(owner, _PERMIT2), type(uint256).max);\n        token.mint(owner, amount);\n        uint256 amountToTransfer = _bound(_random(), 0, amount);\n        address notPermit2 = _randomHashedAddress();\n        address recipient = _randomHashedAddress();\n        vm.prank(notPermit2);\n        if (amountToTransfer != 0) {\n            vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        }\n        token.transferFrom(owner, recipient, amountToTransfer);\n\n        vm.prank(_PERMIT2);\n        token.transferFrom(owner, recipient, amountToTransfer);\n        if (recipient != owner) {\n            assertEq(token.balanceOf(recipient), amountToTransfer);\n            assertEq(token.balanceOf(owner), amount - amountToTransfer);\n        } else {\n            assertEq(token.balanceOf(owner), amount);\n        }\n        assertEq(token.allowance(owner, _PERMIT2), type(uint256).max);\n    }",
                "    function testTransfer() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        token.mint(address(this), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(0xBEEF), 1e18);\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }",
                "    function testTransferFrom() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, address(0xBEEF), 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }",
                "    function testInfiniteApproveTransferFrom() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }",
                "    function testTransferInsufficientBalanceReverts() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        token.mint(address(this), 0.9e18);\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transfer(address(0xBEEF), 1e18);\n    }",
                "    function testTransferFromInsufficientAllowanceReverts() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }",
                "    function testTransferFromInsufficientBalanceReverts() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }",
                "    function testTransfer(address to, uint256 amount) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        token.mint(address(this), amount);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), to, amount);\n        assertTrue(token.transfer(to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == to) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }",
                "    function testTransferFrom(\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address spender,\n        address from,\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = _bound(amount, 0, approval);\n\n        token.mint(from, amount);\n        assertEq(token.balanceOf(from), amount);\n\n        vm.prank(from);\n        token.approve(spender, approval);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, to, amount);\n        vm.prank(spender);\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (approval == type(uint256).max) {\n            assertEq(token.allowance(from, spender), approval);\n        } else {\n            assertEq(token.allowance(from, spender), approval - amount);\n        }\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }",
                "    function testDirectTransfer(uint256) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        _TestTemps memory t = _testTemps();\n        while (t.owner == t.to) (t.to,) = _randomSigner();\n\n        uint256 totalSupply = _random();\n        token.mint(t.owner, totalSupply);\n        assertEq(token.balanceOf(t.owner), totalSupply);\n        assertEq(token.balanceOf(t.to), 0);\n        if (t.amount > totalSupply) {\n            vm.expectRevert(ERC20.InsufficientBalance.selector);\n            token.directTransfer(t.owner, t.to, t.amount);\n        } else {\n            vm.expectEmit(true, true, true, true);\n            emit Transfer(t.owner, t.to, t.amount);\n            token.directTransfer(t.owner, t.to, t.amount);\n            assertEq(token.balanceOf(t.owner), totalSupply - t.amount);\n            assertEq(token.balanceOf(t.to), t.amount);\n        }\n    }",
                "    function testTransferInsufficientBalanceReverts(\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        sendAmount = _bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transfer(to, sendAmount);\n    }",
                "    function testTransferFromInsufficientAllowanceReverts(\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (approval == type(uint256).max) approval--;\n        amount = _bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        vm.prank(from);\n        token.approve(address(this), approval);\n\n        vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, to, amount);\n    }",
                "    function testTransferFromInsufficientBalanceReverts(\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        sendAmount = _bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        vm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transferFrom(from, to, sendAmount);\n    }"
            ],
            "description": "This function transfers a specified amount from one address's account to another. It reduces the sender's account balance by the transfer amount and increases the recipient's account balance by that same amount. The function also tracks the transfer event and returns a success indicator."
        },
        {
            "function": "    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }",
            "tests": [
                "    function testTransferFrom(address owner, uint256 amount) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        assertEq(token.allowance(owner, _PERMIT2), type(uint256).max);\n        token.mint(owner, amount);\n        uint256 amountToTransfer = _bound(_random(), 0, amount);\n        address notPermit2 = _randomHashedAddress();\n        address recipient = _randomHashedAddress();\n        vm.prank(notPermit2);\n        if (amountToTransfer != 0) {\n            vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        }\n        token.transferFrom(owner, recipient, amountToTransfer);\n\n        vm.prank(_PERMIT2);\n        token.transferFrom(owner, recipient, amountToTransfer);\n        if (recipient != owner) {\n            assertEq(token.balanceOf(recipient), amountToTransfer);\n            assertEq(token.balanceOf(owner), amount - amountToTransfer);\n        } else {\n            assertEq(token.balanceOf(owner), amount);\n        }\n        assertEq(token.allowance(owner, _PERMIT2), type(uint256).max);\n    }",
                "    function testTransferFrom() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, address(0xBEEF), 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }",
                "    function testInfiniteApproveTransferFrom() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }",
                "    function testTransferFromInsufficientAllowanceReverts() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }",
                "    function testTransferFromInsufficientBalanceReverts() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }",
                "    function testTransferFrom(\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address spender,\n        address from,\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = _bound(amount, 0, approval);\n\n        token.mint(from, amount);\n        assertEq(token.balanceOf(from), amount);\n\n        vm.prank(from);\n        token.approve(spender, approval);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, to, amount);\n        vm.prank(spender);\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (approval == type(uint256).max) {\n            assertEq(token.allowance(from, spender), approval);\n        } else {\n            assertEq(token.allowance(from, spender), approval - amount);\n        }\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }",
                "    function testTransferFromInsufficientAllowanceReverts(\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (approval == type(uint256).max) approval--;\n        amount = _bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        vm.prank(from);\n        token.approve(address(this), approval);\n\n        vm.expectRevert(ERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, to, amount);\n    }",
                "    function testTransferFromInsufficientBalanceReverts(\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        if (mintAmount == type(uint256).max) mintAmount--;\n        sendAmount = _bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        vm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        vm.expectRevert(ERC20.InsufficientBalance.selector);\n        token.transferFrom(from, to, sendAmount);\n    }"
            ],
            "description": "This function allows one address to transfer a specified amount of tokens from their ownership to another address. It also tracks and manages the allowance for the token being transferred, ensuring that the sender has sufficient permission to make the transaction. The function emits an event to signal the completion of the transfer and updates the balances of both addresses involved in the transaction."
        },
        {
            "function": "    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }",
            "tests": [
                "    function testApproveToPermit2(address owner, uint256 amount) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        vm.prank(owner);\n        if (amount != type(uint256).max) {\n            vm.expectRevert(ERC20.Permit2AllowanceIsFixedAtInfinity.selector);\n        }\n        token.approve(_PERMIT2, amount);\n    }",
                "    function testPermitToPermit2(address owner, uint256 amount) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        vm.prank(owner);\n        if (amount != type(uint256).max) {\n            vm.expectRevert(ERC20.Permit2AllowanceIsFixedAtInfinity.selector);\n        } else {\n            vm.expectRevert(ERC20.InvalidPermit.selector);\n        }\n        token.permit(owner, _PERMIT2, amount, block.timestamp, 0, bytes32(0), bytes32(0));\n    }",
                "    function testPermit() public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        _TestTemps memory t = _testTemps();\n        t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        _expectPermitEmitApproval(t);\n        _permit(t);\n\n        _checkAllowanceAndNonce(t);\n    }",
                "    function testPermit(uint256) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        _TestTemps memory t = _testTemps();\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        _expectPermitEmitApproval(t);\n        _permit(t);\n\n        _checkAllowanceAndNonce(t);\n    }",
                "    function testPermitBadNonceReverts(uint256) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        _TestTemps memory t = _testTemps();\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n        while (t.nonce == 0) t.nonce = _random();\n\n        _signPermit(t);\n\n        vm.expectRevert(ERC20.InvalidPermit.selector);\n        _permit(t);\n    }",
                "    function testPermitBadDeadlineReverts(uint256) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        _TestTemps memory t = _testTemps();\n        if (t.deadline == type(uint256).max) t.deadline--;\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        vm.expectRevert(ERC20.InvalidPermit.selector);\n        t.deadline += 1;\n        _permit(t);\n    }",
                "    function testPermitPastDeadlineReverts(uint256) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        _TestTemps memory t = _testTemps();\n        t.deadline = _bound(t.deadline, 0, block.timestamp - 1);\n\n        _signPermit(t);\n\n        vm.expectRevert(ERC20.PermitExpired.selector);\n        _permit(t);\n    }",
                "    function testPermitReplayReverts(uint256) public {\n        token = new MockERC20ForPermit2(\"Token\", \"TKN\", 18);\n        _TestTemps memory t = _testTemps();\n        if (t.deadline < block.timestamp) t.deadline = block.timestamp;\n\n        _signPermit(t);\n\n        _expectPermitEmitApproval(t);\n        _permit(t);\n        vm.expectRevert(ERC20.InvalidPermit.selector);\n        _permit(t);\n    }"
            ],
            "description": "This function allows a user (owner) to grant permission to another user (spender) to spend a certain amount of resources on their behalf. The permission is valid for a specific deadline and can be verified by the spender using a digital signature. If the verification succeeds, the spender's allowance to spend those resources is updated accordingly."
        },
        {
            "function": "    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }",
            "tests": [
                "    function testSingleDepositWithdraw(uint128 amount) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        if (amount == 0) amount = 1;\n\n        uint256 aliceUnderlyingAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceUnderlyingAmount);\n\n        vm.prank(alice);\n        underlying.approve(address(vault), aliceUnderlyingAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceUnderlyingAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        vm.prank(alice);\n        uint256 aliceShareAmount = vault.deposit(aliceUnderlyingAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial deposit.\n        unchecked {\n            assertEq(aliceUnderlyingAmount, aliceShareAmount);\n            assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n            assertEq(vault.totalSupply(), aliceShareAmount);\n            assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n            assertEq(vault.balanceOf(alice), aliceShareAmount);\n            assertEq(vault.convertToAssets(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n        }\n\n        vm.prank(alice);\n        vault.withdraw(aliceUnderlyingAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }",
                "    function testMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _testMultipleMintDepositRedeemWithdraw(0);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }\n\n    struct _TestTemps {\n        uint256 slippage;\n        address alice;\n        address bob;\n        uint256 mutationUnderlyingAmount;\n        uint256 aliceUnderlyingAmount;\n        uint256 aliceShareAmount;\n        uint256 bobShareAmount;\n        uint256 bobUnderlyingAmount;\n        uint256 preMutationShareBal;\n        uint256 preMutationBal;\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw(uint256 slippage) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |::::::::::::::::::::::::::::::::::::::::::::::::::::::::|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        _TestTemps memory t;\n        t.slippage = slippage;\n        t.alice = address(0x9988776655443322110000112233445566778899);\n        t.bob = address(0x1122334455667788990000998877665544332211);\n\n        t.mutationUnderlyingAmount = 3000;\n\n        underlying.mint(t.alice, 4000);\n\n        vm.prank(t.alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(t.alice, address(vault)), 4000);\n\n        underlying.mint(t.bob, 7001);\n\n        vm.prank(t.bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(t.bob, address(vault)), 7001);\n\n        _testMultipleMintDepositRedeemWithdraw1(t);\n        _testMultipleMintDepositRedeemWithdraw2(t);\n        _testMultipleMintDepositRedeemWithdraw3(t);\n        _testMultipleMintDepositRedeemWithdraw4(t);\n        _testMultipleMintDepositRedeemWithdraw5(t);\n        _testMultipleMintDepositRedeemWithdraw6(t);\n        _testMultipleMintDepositRedeemWithdraw7(t);\n        _testMultipleMintDepositRedeemWithdraw8(t);\n        _testMultipleMintDepositRedeemWithdraw9(t);\n        _testMultipleMintDepositRedeemWithdraw10(t);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw1(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        vm.prank(t.alice);\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(t.alice, t.alice, 2000, 2000);\n        t.aliceUnderlyingAmount = vault.mint(2000, t.alice);\n\n        t.aliceShareAmount = vault.previewDeposit(t.aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(t.aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n        assertEq(vault.convertToAssets(t.aliceShareAmount), t.aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(t.aliceUnderlyingAmount), t.aliceShareAmount);\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(t.aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), t.aliceShareAmount);\n        assertEq(vault.totalAssets(), t.aliceUnderlyingAmount);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw2(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Deposit(t.bob, t.bob, 4000, 4000);\n            t.bobShareAmount = vault.deposit(4000, t.bob);\n            t.bobUnderlyingAmount = vault.previewWithdraw(t.bobShareAmount);\n            assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n            // Expect to have received the requested underlying amount.\n            assertEq(t.bobUnderlyingAmount, 4000);\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(vault.convertToAssets(t.bobShareAmount), t.bobUnderlyingAmount);\n            assertEq(vault.convertToShares(t.bobUnderlyingAmount), t.bobShareAmount);\n\n            // Expect a 1:1 ratio before mutation.\n            assertEq(t.bobShareAmount, t.bobUnderlyingAmount);\n\n            // Sanity check.\n            t.preMutationShareBal = t.aliceShareAmount + t.bobShareAmount;\n            t.preMutationBal = t.aliceUnderlyingAmount + t.bobUnderlyingAmount;\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal);\n            assertEq(vault.totalSupply(), 6000);\n            assertEq(vault.totalAssets(), 6000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw3(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal + t.mutationUnderlyingAmount);\n            assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n            assertEq(\n                vault.convertToAssets(t.aliceShareAmount),\n                t.aliceUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 1 - t.slippage\n            );\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(\n                vault.convertToAssets(t.bobShareAmount),\n                t.bobUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 2 - t.slippage\n            );\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw4(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        vm.prank(t.alice);\n        vault.deposit(2000, t.alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(t.alice), 3333);\n        assertEq(vault.convertToAssets(3333), 4999);\n        assertEq(vault.balanceOf(t.bob), 4000);\n        assertEq(vault.convertToAssets(4000), 6000);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw5(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        unchecked {\n            vm.prank(t.bob);\n            vault.mint(2000, t.bob);\n\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.balanceOf(t.alice), 3333);\n            assertEq(vault.convertToAssets(3333), 5000 - t.slippage);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 9000);\n\n            // Sanity checks:\n            // Alice and t.bob should have spent all their tokens now\n            assertEq(underlying.balanceOf(t.alice), 0);\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 0);\n            // Assets in vault: 4k (t.alice) + 7k (t.bob) + 3k (yield) + 1 (round up)\n            assertEq(vault.totalAssets(), 14001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw6(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.alice)), 6071 - t.slippage);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.bob)), 10929 - t.slippage);\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.totalAssets(), 17001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw7(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 7. Alice redeem 1333 shares (2428 assets)\n        unchecked {\n            vm.prank(t.alice);\n            vault.redeem(1333, t.alice, t.alice);\n\n            assertEq(underlying.balanceOf(t.alice), 2428 - t.slippage);\n            assertEq(vault.totalSupply(), 8000);\n            assertEq(vault.totalAssets(), 14573);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 10929);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw8(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vault.withdraw(2929, t.bob, t.bob);\n\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 2929);\n            assertEq(vault.totalSupply(), 6392);\n            assertEq(vault.totalAssets(), 11644);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw9(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        unchecked {\n            vm.prank(t.alice);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.alice, t.alice, t.alice, 3643, 2000);\n            vault.withdraw(3643, t.alice, t.alice);\n            assertEq(underlying.balanceOf(t.alice), 6071 - t.slippage);\n            assertEq(vault.totalSupply(), 4392);\n            assertEq(vault.totalAssets(), 8001);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw10(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.bob, t.bob, t.bob, 8001 - t.slippage, 4392);\n            vault.redeem(4392, t.bob, t.bob);\n            assertEq(underlying.balanceOf(t.bob), 10930);\n            assertEq(vault.totalSupply(), 0);\n            assertEq(vault.totalAssets() - t.slippage, 0);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 0);\n            assertEq(vault.convertToAssets(0), 0);\n\n            // Sanity check\n            assertEq(underlying.balanceOf(address(vault)) - t.slippage, 0);\n        }\n    }",
                "    function testDepositWithNotEnoughApprovalReverts() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n        assertEq(underlying.allowance(address(this), address(vault)), 0.5e18);\n\n        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n        vault.deposit(1e18, address(this));\n    }",
                "    function testDepositWithNoApprovalReverts() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n        vault.deposit(1e18, address(this));\n    }"
            ],
            "description": "This function allows a user to deposit assets into a contract, receiving shares in return. The contract then transfers the deposited assets to an address (the receiver) and mints new shares to the receiver's account. The function also emits an event upon successful execution and calls another external function (afterDeposit) after the deposit is processed."
        },
        {
            "function": "    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }",
            "tests": [
                "    function testSingleMintRedeem(uint128 amount) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        if (amount == 0) amount = 1;\n\n        uint256 aliceShareAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceShareAmount);\n\n        vm.prank(alice);\n        underlying.approve(address(vault), aliceShareAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceShareAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        vm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(aliceShareAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial mint.\n        unchecked {\n            assertEq(aliceShareAmount, aliceUnderlyingAmount);\n            assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n            assertEq(vault.totalSupply(), aliceShareAmount);\n            assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n            assertEq(vault.balanceOf(alice), aliceUnderlyingAmount);\n            assertEq(vault.convertToAssets(aliceUnderlyingAmount), aliceUnderlyingAmount);\n            assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n        }\n\n        vm.prank(alice);\n        vault.redeem(aliceShareAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }",
                "    function testMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _testMultipleMintDepositRedeemWithdraw(0);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }\n\n    struct _TestTemps {\n        uint256 slippage;\n        address alice;\n        address bob;\n        uint256 mutationUnderlyingAmount;\n        uint256 aliceUnderlyingAmount;\n        uint256 aliceShareAmount;\n        uint256 bobShareAmount;\n        uint256 bobUnderlyingAmount;\n        uint256 preMutationShareBal;\n        uint256 preMutationBal;\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw(uint256 slippage) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |::::::::::::::::::::::::::::::::::::::::::::::::::::::::|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        _TestTemps memory t;\n        t.slippage = slippage;\n        t.alice = address(0x9988776655443322110000112233445566778899);\n        t.bob = address(0x1122334455667788990000998877665544332211);\n\n        t.mutationUnderlyingAmount = 3000;\n\n        underlying.mint(t.alice, 4000);\n\n        vm.prank(t.alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(t.alice, address(vault)), 4000);\n\n        underlying.mint(t.bob, 7001);\n\n        vm.prank(t.bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(t.bob, address(vault)), 7001);\n\n        _testMultipleMintDepositRedeemWithdraw1(t);\n        _testMultipleMintDepositRedeemWithdraw2(t);\n        _testMultipleMintDepositRedeemWithdraw3(t);\n        _testMultipleMintDepositRedeemWithdraw4(t);\n        _testMultipleMintDepositRedeemWithdraw5(t);\n        _testMultipleMintDepositRedeemWithdraw6(t);\n        _testMultipleMintDepositRedeemWithdraw7(t);\n        _testMultipleMintDepositRedeemWithdraw8(t);\n        _testMultipleMintDepositRedeemWithdraw9(t);\n        _testMultipleMintDepositRedeemWithdraw10(t);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw1(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        vm.prank(t.alice);\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(t.alice, t.alice, 2000, 2000);\n        t.aliceUnderlyingAmount = vault.mint(2000, t.alice);\n\n        t.aliceShareAmount = vault.previewDeposit(t.aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(t.aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n        assertEq(vault.convertToAssets(t.aliceShareAmount), t.aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(t.aliceUnderlyingAmount), t.aliceShareAmount);\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(t.aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), t.aliceShareAmount);\n        assertEq(vault.totalAssets(), t.aliceUnderlyingAmount);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw2(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Deposit(t.bob, t.bob, 4000, 4000);\n            t.bobShareAmount = vault.deposit(4000, t.bob);\n            t.bobUnderlyingAmount = vault.previewWithdraw(t.bobShareAmount);\n            assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n            // Expect to have received the requested underlying amount.\n            assertEq(t.bobUnderlyingAmount, 4000);\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(vault.convertToAssets(t.bobShareAmount), t.bobUnderlyingAmount);\n            assertEq(vault.convertToShares(t.bobUnderlyingAmount), t.bobShareAmount);\n\n            // Expect a 1:1 ratio before mutation.\n            assertEq(t.bobShareAmount, t.bobUnderlyingAmount);\n\n            // Sanity check.\n            t.preMutationShareBal = t.aliceShareAmount + t.bobShareAmount;\n            t.preMutationBal = t.aliceUnderlyingAmount + t.bobUnderlyingAmount;\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal);\n            assertEq(vault.totalSupply(), 6000);\n            assertEq(vault.totalAssets(), 6000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw3(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal + t.mutationUnderlyingAmount);\n            assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n            assertEq(\n                vault.convertToAssets(t.aliceShareAmount),\n                t.aliceUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 1 - t.slippage\n            );\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(\n                vault.convertToAssets(t.bobShareAmount),\n                t.bobUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 2 - t.slippage\n            );\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw4(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        vm.prank(t.alice);\n        vault.deposit(2000, t.alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(t.alice), 3333);\n        assertEq(vault.convertToAssets(3333), 4999);\n        assertEq(vault.balanceOf(t.bob), 4000);\n        assertEq(vault.convertToAssets(4000), 6000);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw5(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        unchecked {\n            vm.prank(t.bob);\n            vault.mint(2000, t.bob);\n\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.balanceOf(t.alice), 3333);\n            assertEq(vault.convertToAssets(3333), 5000 - t.slippage);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 9000);\n\n            // Sanity checks:\n            // Alice and t.bob should have spent all their tokens now\n            assertEq(underlying.balanceOf(t.alice), 0);\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 0);\n            // Assets in vault: 4k (t.alice) + 7k (t.bob) + 3k (yield) + 1 (round up)\n            assertEq(vault.totalAssets(), 14001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw6(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.alice)), 6071 - t.slippage);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.bob)), 10929 - t.slippage);\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.totalAssets(), 17001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw7(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 7. Alice redeem 1333 shares (2428 assets)\n        unchecked {\n            vm.prank(t.alice);\n            vault.redeem(1333, t.alice, t.alice);\n\n            assertEq(underlying.balanceOf(t.alice), 2428 - t.slippage);\n            assertEq(vault.totalSupply(), 8000);\n            assertEq(vault.totalAssets(), 14573);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 10929);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw8(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vault.withdraw(2929, t.bob, t.bob);\n\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 2929);\n            assertEq(vault.totalSupply(), 6392);\n            assertEq(vault.totalAssets(), 11644);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw9(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        unchecked {\n            vm.prank(t.alice);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.alice, t.alice, t.alice, 3643, 2000);\n            vault.withdraw(3643, t.alice, t.alice);\n            assertEq(underlying.balanceOf(t.alice), 6071 - t.slippage);\n            assertEq(vault.totalSupply(), 4392);\n            assertEq(vault.totalAssets(), 8001);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw10(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.bob, t.bob, t.bob, 8001 - t.slippage, 4392);\n            vault.redeem(4392, t.bob, t.bob);\n            assertEq(underlying.balanceOf(t.bob), 10930);\n            assertEq(vault.totalSupply(), 0);\n            assertEq(vault.totalAssets() - t.slippage, 0);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 0);\n            assertEq(vault.convertToAssets(0), 0);\n\n            // Sanity check\n            assertEq(underlying.balanceOf(address(vault)) - t.slippage, 0);\n        }\n    }",
                "    function testMintWithNoApprovalReverts() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        vm.expectRevert(SafeTransferLib.TransferFromFailed.selector);\n        vault.mint(1e18, address(this));\n    }",
                "    function testMintZero() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        vault.mint(0, address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(0), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }"
            ],
            "description": "This function allows someone to mint a specified number of assets, which are then transferred from the sender to the contract and distributed to a designated recipient. After the transfer, the contract updates its internal state by minting the specified amount of assets for the recipient. The transaction also triggers an event indicating that a deposit has been made."
        },
        {
            "function": "    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }",
            "tests": [
                "    function testSingleDepositWithdraw(uint128 amount) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        if (amount == 0) amount = 1;\n\n        uint256 aliceUnderlyingAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceUnderlyingAmount);\n\n        vm.prank(alice);\n        underlying.approve(address(vault), aliceUnderlyingAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceUnderlyingAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        vm.prank(alice);\n        uint256 aliceShareAmount = vault.deposit(aliceUnderlyingAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial deposit.\n        unchecked {\n            assertEq(aliceUnderlyingAmount, aliceShareAmount);\n            assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n            assertEq(vault.totalSupply(), aliceShareAmount);\n            assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n            assertEq(vault.balanceOf(alice), aliceShareAmount);\n            assertEq(vault.convertToAssets(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n        }\n\n        vm.prank(alice);\n        vault.withdraw(aliceUnderlyingAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }",
                "    function testMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _testMultipleMintDepositRedeemWithdraw(0);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }\n\n    struct _TestTemps {\n        uint256 slippage;\n        address alice;\n        address bob;\n        uint256 mutationUnderlyingAmount;\n        uint256 aliceUnderlyingAmount;\n        uint256 aliceShareAmount;\n        uint256 bobShareAmount;\n        uint256 bobUnderlyingAmount;\n        uint256 preMutationShareBal;\n        uint256 preMutationBal;\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw(uint256 slippage) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |::::::::::::::::::::::::::::::::::::::::::::::::::::::::|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        _TestTemps memory t;\n        t.slippage = slippage;\n        t.alice = address(0x9988776655443322110000112233445566778899);\n        t.bob = address(0x1122334455667788990000998877665544332211);\n\n        t.mutationUnderlyingAmount = 3000;\n\n        underlying.mint(t.alice, 4000);\n\n        vm.prank(t.alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(t.alice, address(vault)), 4000);\n\n        underlying.mint(t.bob, 7001);\n\n        vm.prank(t.bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(t.bob, address(vault)), 7001);\n\n        _testMultipleMintDepositRedeemWithdraw1(t);\n        _testMultipleMintDepositRedeemWithdraw2(t);\n        _testMultipleMintDepositRedeemWithdraw3(t);\n        _testMultipleMintDepositRedeemWithdraw4(t);\n        _testMultipleMintDepositRedeemWithdraw5(t);\n        _testMultipleMintDepositRedeemWithdraw6(t);\n        _testMultipleMintDepositRedeemWithdraw7(t);\n        _testMultipleMintDepositRedeemWithdraw8(t);\n        _testMultipleMintDepositRedeemWithdraw9(t);\n        _testMultipleMintDepositRedeemWithdraw10(t);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw1(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        vm.prank(t.alice);\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(t.alice, t.alice, 2000, 2000);\n        t.aliceUnderlyingAmount = vault.mint(2000, t.alice);\n\n        t.aliceShareAmount = vault.previewDeposit(t.aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(t.aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n        assertEq(vault.convertToAssets(t.aliceShareAmount), t.aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(t.aliceUnderlyingAmount), t.aliceShareAmount);\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(t.aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), t.aliceShareAmount);\n        assertEq(vault.totalAssets(), t.aliceUnderlyingAmount);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw2(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Deposit(t.bob, t.bob, 4000, 4000);\n            t.bobShareAmount = vault.deposit(4000, t.bob);\n            t.bobUnderlyingAmount = vault.previewWithdraw(t.bobShareAmount);\n            assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n            // Expect to have received the requested underlying amount.\n            assertEq(t.bobUnderlyingAmount, 4000);\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(vault.convertToAssets(t.bobShareAmount), t.bobUnderlyingAmount);\n            assertEq(vault.convertToShares(t.bobUnderlyingAmount), t.bobShareAmount);\n\n            // Expect a 1:1 ratio before mutation.\n            assertEq(t.bobShareAmount, t.bobUnderlyingAmount);\n\n            // Sanity check.\n            t.preMutationShareBal = t.aliceShareAmount + t.bobShareAmount;\n            t.preMutationBal = t.aliceUnderlyingAmount + t.bobUnderlyingAmount;\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal);\n            assertEq(vault.totalSupply(), 6000);\n            assertEq(vault.totalAssets(), 6000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw3(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal + t.mutationUnderlyingAmount);\n            assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n            assertEq(\n                vault.convertToAssets(t.aliceShareAmount),\n                t.aliceUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 1 - t.slippage\n            );\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(\n                vault.convertToAssets(t.bobShareAmount),\n                t.bobUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 2 - t.slippage\n            );\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw4(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        vm.prank(t.alice);\n        vault.deposit(2000, t.alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(t.alice), 3333);\n        assertEq(vault.convertToAssets(3333), 4999);\n        assertEq(vault.balanceOf(t.bob), 4000);\n        assertEq(vault.convertToAssets(4000), 6000);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw5(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        unchecked {\n            vm.prank(t.bob);\n            vault.mint(2000, t.bob);\n\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.balanceOf(t.alice), 3333);\n            assertEq(vault.convertToAssets(3333), 5000 - t.slippage);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 9000);\n\n            // Sanity checks:\n            // Alice and t.bob should have spent all their tokens now\n            assertEq(underlying.balanceOf(t.alice), 0);\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 0);\n            // Assets in vault: 4k (t.alice) + 7k (t.bob) + 3k (yield) + 1 (round up)\n            assertEq(vault.totalAssets(), 14001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw6(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.alice)), 6071 - t.slippage);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.bob)), 10929 - t.slippage);\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.totalAssets(), 17001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw7(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 7. Alice redeem 1333 shares (2428 assets)\n        unchecked {\n            vm.prank(t.alice);\n            vault.redeem(1333, t.alice, t.alice);\n\n            assertEq(underlying.balanceOf(t.alice), 2428 - t.slippage);\n            assertEq(vault.totalSupply(), 8000);\n            assertEq(vault.totalAssets(), 14573);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 10929);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw8(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vault.withdraw(2929, t.bob, t.bob);\n\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 2929);\n            assertEq(vault.totalSupply(), 6392);\n            assertEq(vault.totalAssets(), 11644);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw9(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        unchecked {\n            vm.prank(t.alice);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.alice, t.alice, t.alice, 3643, 2000);\n            vault.withdraw(3643, t.alice, t.alice);\n            assertEq(underlying.balanceOf(t.alice), 6071 - t.slippage);\n            assertEq(vault.totalSupply(), 4392);\n            assertEq(vault.totalAssets(), 8001);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw10(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.bob, t.bob, t.bob, 8001 - t.slippage, 4392);\n            vault.redeem(4392, t.bob, t.bob);\n            assertEq(underlying.balanceOf(t.bob), 10930);\n            assertEq(vault.totalSupply(), 0);\n            assertEq(vault.totalAssets() - t.slippage, 0);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 0);\n            assertEq(vault.convertToAssets(0), 0);\n\n            // Sanity check\n            assertEq(underlying.balanceOf(address(vault)) - t.slippage, 0);\n        }\n    }",
                "    function testWithdrawWithNotEnoughUnderlyingAmountReverts() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vm.expectRevert(ERC4626.WithdrawMoreThanMax.selector);\n        vault.withdraw(1e18, address(this), address(this));\n    }",
                "    function testWithdrawWithNoUnderlyingAmountReverts() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        vm.expectRevert(ERC4626.WithdrawMoreThanMax.selector);\n        vault.withdraw(1e18, address(this), address(this));\n    }",
                "    function testWithdrawZero() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        vault.withdraw(0, address(this), address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(0), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }"
            ],
            "description": "This function allows the owner to withdraw a specified amount of assets from their account and transfer them to another recipient. It also updates the allowance for the sender (if they are an approver) and notifies other parts of the system that the withdrawal has occurred. The function ensures that the sender is the owner, handles rounding issues, and follows a set order of operations before transferring the assets."
        },
        {
            "function": "    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }",
            "tests": [
                "    function testSingleMintRedeem(uint128 amount) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        if (amount == 0) amount = 1;\n\n        uint256 aliceShareAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceShareAmount);\n\n        vm.prank(alice);\n        underlying.approve(address(vault), aliceShareAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceShareAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        vm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(aliceShareAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial mint.\n        unchecked {\n            assertEq(aliceShareAmount, aliceUnderlyingAmount);\n            assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n            assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n            assertEq(vault.totalSupply(), aliceShareAmount);\n            assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n            assertEq(vault.balanceOf(alice), aliceUnderlyingAmount);\n            assertEq(vault.convertToAssets(aliceUnderlyingAmount), aliceUnderlyingAmount);\n            assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n        }\n\n        vm.prank(alice);\n        vault.redeem(aliceShareAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }",
                "    function testMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _testMultipleMintDepositRedeemWithdraw(0);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }",
                "    function testVirtualSharesMultipleMintDepositRedeemWithdraw() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        _replaceWithVirtualSharesVault();\n        _testMultipleMintDepositRedeemWithdraw(1);\n    }\n\n    struct _TestTemps {\n        uint256 slippage;\n        address alice;\n        address bob;\n        uint256 mutationUnderlyingAmount;\n        uint256 aliceUnderlyingAmount;\n        uint256 aliceShareAmount;\n        uint256 bobShareAmount;\n        uint256 bobUnderlyingAmount;\n        uint256 preMutationShareBal;\n        uint256 preMutationBal;\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw(uint256 slippage) public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |::::::::::::::::::::::::::::::::::::::::::::::::::::::::|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        _TestTemps memory t;\n        t.slippage = slippage;\n        t.alice = address(0x9988776655443322110000112233445566778899);\n        t.bob = address(0x1122334455667788990000998877665544332211);\n\n        t.mutationUnderlyingAmount = 3000;\n\n        underlying.mint(t.alice, 4000);\n\n        vm.prank(t.alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(t.alice, address(vault)), 4000);\n\n        underlying.mint(t.bob, 7001);\n\n        vm.prank(t.bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(t.bob, address(vault)), 7001);\n\n        _testMultipleMintDepositRedeemWithdraw1(t);\n        _testMultipleMintDepositRedeemWithdraw2(t);\n        _testMultipleMintDepositRedeemWithdraw3(t);\n        _testMultipleMintDepositRedeemWithdraw4(t);\n        _testMultipleMintDepositRedeemWithdraw5(t);\n        _testMultipleMintDepositRedeemWithdraw6(t);\n        _testMultipleMintDepositRedeemWithdraw7(t);\n        _testMultipleMintDepositRedeemWithdraw8(t);\n        _testMultipleMintDepositRedeemWithdraw9(t);\n        _testMultipleMintDepositRedeemWithdraw10(t);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw1(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        vm.prank(t.alice);\n        vm.expectEmit(true, true, true, true);\n        emit Deposit(t.alice, t.alice, 2000, 2000);\n        t.aliceUnderlyingAmount = vault.mint(2000, t.alice);\n\n        t.aliceShareAmount = vault.previewDeposit(t.aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(t.aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n        assertEq(vault.convertToAssets(t.aliceShareAmount), t.aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(t.aliceUnderlyingAmount), t.aliceShareAmount);\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(t.aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), t.aliceShareAmount);\n        assertEq(vault.totalAssets(), t.aliceUnderlyingAmount);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw2(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Deposit(t.bob, t.bob, 4000, 4000);\n            t.bobShareAmount = vault.deposit(4000, t.bob);\n            t.bobUnderlyingAmount = vault.previewWithdraw(t.bobShareAmount);\n            assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n            // Expect to have received the requested underlying amount.\n            assertEq(t.bobUnderlyingAmount, 4000);\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(vault.convertToAssets(t.bobShareAmount), t.bobUnderlyingAmount);\n            assertEq(vault.convertToShares(t.bobUnderlyingAmount), t.bobShareAmount);\n\n            // Expect a 1:1 ratio before mutation.\n            assertEq(t.bobShareAmount, t.bobUnderlyingAmount);\n\n            // Sanity check.\n            t.preMutationShareBal = t.aliceShareAmount + t.bobShareAmount;\n            t.preMutationBal = t.aliceUnderlyingAmount + t.bobUnderlyingAmount;\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal);\n            assertEq(vault.totalSupply(), 6000);\n            assertEq(vault.totalAssets(), 6000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw3(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.totalSupply(), t.preMutationShareBal);\n            assertEq(vault.totalAssets(), t.preMutationBal + t.mutationUnderlyingAmount);\n            assertEq(vault.balanceOf(t.alice), t.aliceShareAmount);\n            assertEq(\n                vault.convertToAssets(t.aliceShareAmount),\n                t.aliceUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 1 - t.slippage\n            );\n            assertEq(vault.balanceOf(t.bob), t.bobShareAmount);\n            assertEq(\n                vault.convertToAssets(t.bobShareAmount),\n                t.bobUnderlyingAmount + (t.mutationUnderlyingAmount / 3) * 2 - t.slippage\n            );\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw4(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        vm.prank(t.alice);\n        vault.deposit(2000, t.alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(t.alice), 3333);\n        assertEq(vault.convertToAssets(3333), 4999);\n        assertEq(vault.balanceOf(t.bob), 4000);\n        assertEq(vault.convertToAssets(4000), 6000);\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw5(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        unchecked {\n            vm.prank(t.bob);\n            vault.mint(2000, t.bob);\n\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.balanceOf(t.alice), 3333);\n            assertEq(vault.convertToAssets(3333), 5000 - t.slippage);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 9000);\n\n            // Sanity checks:\n            // Alice and t.bob should have spent all their tokens now\n            assertEq(underlying.balanceOf(t.alice), 0);\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 0);\n            // Assets in vault: 4k (t.alice) + 7k (t.bob) + 3k (yield) + 1 (round up)\n            assertEq(vault.totalAssets(), 14001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw6(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        unchecked {\n            underlying.mint(address(vault), t.mutationUnderlyingAmount);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.alice)), 6071 - t.slippage);\n            assertEq(vault.convertToAssets(vault.balanceOf(t.bob)), 10929 - t.slippage);\n            assertEq(vault.totalSupply(), 9333);\n            assertEq(vault.totalAssets(), 17001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw7(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 7. Alice redeem 1333 shares (2428 assets)\n        unchecked {\n            vm.prank(t.alice);\n            vault.redeem(1333, t.alice, t.alice);\n\n            assertEq(underlying.balanceOf(t.alice), 2428 - t.slippage);\n            assertEq(vault.totalSupply(), 8000);\n            assertEq(vault.totalAssets(), 14573);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 6000);\n            assertEq(vault.convertToAssets(6000), 10929);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw8(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        unchecked {\n            vm.prank(t.bob);\n            vault.withdraw(2929, t.bob, t.bob);\n\n            assertEq(underlying.balanceOf(t.bob) - t.slippage, 2929);\n            assertEq(vault.totalSupply(), 6392);\n            assertEq(vault.totalAssets(), 11644);\n            assertEq(vault.balanceOf(t.alice), 2000);\n            assertEq(vault.convertToAssets(2000), 3643);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8000);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw9(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        unchecked {\n            vm.prank(t.alice);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.alice, t.alice, t.alice, 3643, 2000);\n            vault.withdraw(3643, t.alice, t.alice);\n            assertEq(underlying.balanceOf(t.alice), 6071 - t.slippage);\n            assertEq(vault.totalSupply(), 4392);\n            assertEq(vault.totalAssets(), 8001);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 4392);\n            assertEq(vault.convertToAssets(4392), 8001 - t.slippage);\n        }\n    }",
                "    function _testMultipleMintDepositRedeemWithdraw10(_TestTemps memory t) internal {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        unchecked {\n            vm.prank(t.bob);\n            vm.expectEmit(true, true, true, true);\n            emit Withdraw(t.bob, t.bob, t.bob, 8001 - t.slippage, 4392);\n            vault.redeem(4392, t.bob, t.bob);\n            assertEq(underlying.balanceOf(t.bob), 10930);\n            assertEq(vault.totalSupply(), 0);\n            assertEq(vault.totalAssets() - t.slippage, 0);\n            assertEq(vault.balanceOf(t.alice), 0);\n            assertEq(vault.convertToAssets(0), 0);\n            assertEq(vault.balanceOf(t.bob), 0);\n            assertEq(vault.convertToAssets(0), 0);\n\n            // Sanity check\n            assertEq(underlying.balanceOf(address(vault)) - t.slippage, 0);\n        }\n    }",
                "    function testRedeemWithNotEnoughShareAmountReverts() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vm.expectRevert(ERC4626.RedeemMoreThanMax.selector);\n        vault.redeem(1e18, address(this), address(this));\n    }",
                "    function testRedeemWithNoShareAmountReverts() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(address(underlying), \"Mock Token Vault\", \"vwTKN\", false, 0);\n        vm.expectRevert(ERC4626.RedeemMoreThanMax.selector);\n        vault.redeem(1e18, address(this), address(this));\n    }"
            ],
            "description": "This function allows an owner to redeem shares of a token in exchange for the equivalent amount of the underlying asset. The redemption process includes checking if the sender has the necessary approval, updating the approval limit, and then transferring the redeemed assets to the designated recipient."
        },
        {
            "function": "    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }",
            "tests": [
                "    function testOwnerOfNonExistent(uint256 id) public {\n        token = new MockERC721();\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _ownerOf(id);\n    }"
            ],
            "description": "This function allows a user to retrieve the address of the creator (\"owner\") of an NFT (a unique digital asset) with a specified ID. If no such owner exists for the given ID, it returns an error message indicating that the token has not been minted. The returned owner address is optional and will be 0 by default if the ID does not have an associated owner."
        },
        {
            "function": "    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }",
            "tests": [
                "    function testIsApprovedOrOwner(uint256 id) public {\n        token = new MockERC721();\n        (address owner0, address owner1) = _owners();\n\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        token.isApprovedOrOwner(owner0, id);\n\n        token.mint(owner0, id);\n        assertEq(token.isApprovedOrOwner(owner0, id), true);\n\n        vm.prank(owner0);\n        _transferFrom(owner0, owner1, id);\n        assertEq(token.isApprovedOrOwner(owner0, id), false);\n\n        vm.prank(owner1);\n        _setApprovalForAll(owner0, true);\n        assertEq(token.isApprovedOrOwner(owner0, id), true);\n\n        vm.prank(owner1);\n        _setApprovalForAll(owner0, false);\n        assertEq(token.isApprovedOrOwner(owner0, id), false);\n\n        vm.prank(owner1);\n        _approve(owner0, id);\n        assertEq(token.isApprovedOrOwner(owner0, id), true);\n    }",
                "    function testApprove(uint256 id) public {\n        token = new MockERC721();\n        (address spender,) = _randomSigner();\n\n        token.mint(address(this), id);\n\n        _expectApprovalEvent(address(this), spender, id);\n        _approve(spender, id);\n        assertEq(_getApproved(id), spender);\n    }",
                "    function testApproveBurn(uint256 id) public {\n        token = new MockERC721();\n        (address spender,) = _randomSigner();\n\n        token.mint(address(this), id);\n\n        _approve(spender, id);\n\n        token.uncheckedBurn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _getApproved(id);\n\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _ownerOf(id);\n    }",
                "    function testApproveAll(uint256) public {\n        token = new MockERC721();\n        (address operator,) = _randomSigner();\n        bool approved = _randomChance(2);\n        _expectApprovalForAllEvent(address(this), operator, approved);\n        _setApprovalForAll(operator, approved);\n        assertEq(token.isApprovedForAll(address(this), operator), approved);\n    }",
                "    function testTransferFromApproveAll(uint256 id) public {\n        token = new MockERC721();\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _transferFrom(from, to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testApproveNonExistentReverts(uint256 id, address to) public {\n        token = new MockERC721();\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _approve(to, id);\n    }",
                "    function testApproveUnauthorizedReverts(uint256 id) public {\n        token = new MockERC721();\n        (address owner, address to) = _owners();\n\n        token.mint(owner, id);\n        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);\n        _approve(to, id);\n    }"
            ],
            "description": "This function approves a spender to hold an asset with the specified ID. It checks that the caller is authorized and updates the approval status for that ID. When successful, it broadcasts an event indicating the new approver."
        },
        {
            "function": "    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }",
            "tests": [
                "    function testTransferFrom() public {\n        token = new MockERC721();\n        address owner = _randomNonZeroAddress();\n        token.mint(owner, 0);\n        vm.prank(owner);\n        token.transferFrom(owner, address(this), 0);\n    }",
                "    function testTransferFrom(uint256 id) public {\n        token = new MockERC721();\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        if (_randomChance(2)) {\n            uint256 r = _random() % 3;\n            if (r == 0) {\n                vm.prank(from);\n                _approve(address(this), id);\n                _expectTransferEvent(from, to, id);\n                _transferFrom(from, to, id);\n            }\n            if (r == 1) {\n                vm.prank(from);\n                _setApprovalForAll(address(this), true);\n                _expectTransferEvent(from, to, id);\n                _transferFrom(from, to, id);\n            }\n            if (r == 2) {\n                vm.prank(from);\n                _expectTransferEvent(from, address(this), id);\n                _transferFrom(from, address(this), id);\n                _expectTransferEvent(address(this), to, id);\n                _transferFrom(address(this), to, id);\n            }\n        } else {\n            (address temp,) = _randomSigner();\n            while (temp == from || temp == to) (temp,) = _randomSigner();\n            if (_randomChance(2)) {\n                _expectTransferEvent(from, temp, id);\n                token.uncheckedTransferFrom(from, temp, id);\n            } else {\n                vm.prank(from);\n                _expectTransferEvent(from, temp, id);\n                _transferFrom(from, temp, id);\n            }\n            _expectTransferEvent(temp, to, id);\n            token.uncheckedTransferFrom(temp, to, id);\n        }\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testTransferFromSelf(uint256 id) public {\n        token = new MockERC721();\n        (address to,) = _randomSigner();\n\n        token.mint(address(this), id);\n\n        _transferFrom(address(this), to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }",
                "    function testTransferFromApproveAll(uint256 id) public {\n        token = new MockERC721();\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _transferFrom(from, to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testSafeTransferFromToEOA(uint256 id) public {\n        token = new MockERC721();\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        token = new MockERC721();\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.data(), \"\");\n    }",
                "    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes memory data) public {\n        token = new MockERC721();\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(recipient.data(), data);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testTransferFromNotExistentReverts(address from, address to, uint256 id) public {\n        token = new MockERC721();\n        vm.expectRevert(ERC721.TokenDoesNotExist.selector);\n        _transferFrom(from, to, id);\n    }",
                "    function testTransferFromWrongFromReverts(address to, uint256 id) public {\n        token = new MockERC721();\n        (address owner, address from) = _owners();\n\n        token.mint(owner, id);\n        vm.expectRevert(ERC721.TransferFromIncorrectOwner.selector);\n        _transferFrom(from, to, id);\n    }",
                "    function testTransferFromToZeroReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n\n        vm.expectRevert(ERC721.TransferToZeroAddress.selector);\n        _transferFrom(address(this), address(0), id);\n    }",
                "    function testTransferFromNotOwner(uint256 id) public {\n        token = new MockERC721();\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.expectRevert(ERC721.NotOwnerNorApproved.selector);\n        _transferFrom(from, to, id);\n    }",
                "    function testSafeTransferFromToNonERC721RecipientReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), address(to), id);\n    }",
                "    function testSafeTransferFromToNonERC721RecipientWithDataReverts(uint256 id, bytes memory data)\n        token = new MockERC721();\n        public\n    {\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }",
                "    function testSafeTransferFromToRevertingERC721RecipientReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id);\n    }",
                "    function testSafeTransferFromToRevertingERC721RecipientWithDataReverts(\n        token = new MockERC721();\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id, data);\n    }",
                "    function testSafeTransferFromToERC721RecipientWithWrongReturnDataReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id);\n    }",
                "    function testSafeTransferFromToERC721RecipientWithWrongReturnDataWithDataReverts(\n        token = new MockERC721();\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }"
            ],
            "description": "This function allows a user to transfer ownership of an asset (identified by an ID) from one address to another. The transfer is conditional on the sender being the current owner, the recipient not being zero address, and the sender or the recipient having approval to transfer the asset. After the transfer, the new owner is updated and the approved users for that asset are removed."
        },
        {
            "function": "    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }",
            "tests": [
                "    function testSafeTransferFromToEOA(uint256 id) public {\n        token = new MockERC721();\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        token = new MockERC721();\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.data(), \"\");\n    }",
                "    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes memory data) public {\n        token = new MockERC721();\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(recipient.data(), data);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testSafeTransferFromToNonERC721RecipientReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), address(to), id);\n    }",
                "    function testSafeTransferFromToNonERC721RecipientWithDataReverts(uint256 id, bytes memory data)\n        token = new MockERC721();\n        public\n    {\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }",
                "    function testSafeTransferFromToRevertingERC721RecipientReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id);\n    }",
                "    function testSafeTransferFromToRevertingERC721RecipientWithDataReverts(\n        token = new MockERC721();\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id, data);\n    }",
                "    function testSafeTransferFromToERC721RecipientWithWrongReturnDataReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id);\n    }",
                "    function testSafeTransferFromToERC721RecipientWithWrongReturnDataWithDataReverts(\n        token = new MockERC721();\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }"
            ],
            "description": "This function is used to safely transfer ownership of a specific item (identified by `id`) from one address (`from`) to another address (`to`). It checks if the recipient address has implemented the standard ERC721 token receiver function and calls it with the same parameters as before, ensuring that the transfer happens in a standardized way."
        },
        {
            "function": "    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }",
            "tests": [
                "    function testSafeTransferFromToEOA(uint256 id) public {\n        token = new MockERC721();\n        (address from, address to) = _owners();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, to, id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        token = new MockERC721();\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.data(), \"\");\n    }",
                "    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes memory data) public {\n        token = new MockERC721();\n        (address from,) = _randomSigner();\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        vm.prank(from);\n        _setApprovalForAll(address(this), true);\n\n        _safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(recipient.data(), data);\n        assertEq(recipient.id(), id);\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n\n        assertEq(_getApproved(id), address(0));\n        assertEq(_ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }",
                "    function testSafeTransferFromToNonERC721RecipientReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), address(to), id);\n    }",
                "    function testSafeTransferFromToNonERC721RecipientWithDataReverts(uint256 id, bytes memory data)\n        token = new MockERC721();\n        public\n    {\n        token.mint(address(this), id);\n        address to = address(new NonERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }",
                "    function testSafeTransferFromToRevertingERC721RecipientReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id);\n    }",
                "    function testSafeTransferFromToRevertingERC721RecipientWithDataReverts(\n        token = new MockERC721();\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new RevertingERC721Recipient());\n        vm.expectRevert(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector));\n        _safeTransferFrom(address(this), to, id, data);\n    }",
                "    function testSafeTransferFromToERC721RecipientWithWrongReturnDataReverts(uint256 id) public {\n        token = new MockERC721();\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id);\n    }",
                "    function testSafeTransferFromToERC721RecipientWithWrongReturnDataWithDataReverts(\n        token = new MockERC721();\n        uint256 id,\n        bytes memory data\n    ) public {\n        token.mint(address(this), id);\n        address to = address(new WrongReturnDataERC721Recipient());\n        vm.expectRevert(ERC721.TransferToNonERC721ReceiverImplementer.selector);\n        _safeTransferFrom(address(this), to, id, data);\n    }"
            ],
            "description": "This function allows a token transfer between two users, but with an additional layer of security to prevent unauthorized recipients from receiving tokens. It ensures that the recipient is a known and approved address that has been configured to receive ERC-721 tokens correctly."
        }
    ]
}